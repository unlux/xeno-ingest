# Xeno SDE Internship Assignment Tracker

## Phase 1: Data Ingestion & Core Setup

- [x] **OAuth with Google:** (Assumed complete for backend, frontend handles login flow)
- [x] **Dataset:** (Sample data generation script `generate-dataset.js` created and used for testing)
- [x] **Database Setup (Prisma):**
  - [x] Initialized Prisma schema (`prisma/schema.prisma`)
  - [x] Defined `User` model (using UUIDs)
  - [x] Defined `Order` model (using UUIDs)
- [x] **Data Ingestion APIs (Pub-Sub Architecture):**
  - [x] Customer Ingestion API (`POST /api/user`):
    - [x] Accepts array of customer data.
    - [x] Adds jobs to `customerQueue`.
  - [x] Order Ingestion API (`POST /api/order`):
    - [x] Accepts array of order data.
    - [x] Adds jobs to `orderQueue`.
- [x] **Message Queue (Redis & BullMQ):**
  - [x] Configured BullMQ for `customerQueue`.
  - [x] Configured BullMQ for `orderQueue`.
- [x] **Asynchronous Workers:**
  - [x] Created worker for `customerQueue` (processes `persistent-batch` jobs).
    - [x] Persists customer data to DB.
  - [x] Created worker for `orderQueue` (processes `persistent-order-batch` jobs).
    - [x] Persists order data to DB.
- [x] **Initial Testing:**
  - [x] Tested customer ingestion flow.
  - [x] Tested order ingestion flow.

## Phase 2: Campaign Management & Delivery

- [x] **API Input Validation (Zod):**
  - [x] Customer Ingestion API (`/api/user`):
    - [x] Defined comprehensive `userSchema` (including nested `addressSchema`) matching Prisma model.
    - [x] Implemented `usersSchema.safeParse()` for request body.
    - [x] Return 400 on validation failure with detailed field errors.
  - [x] Order Ingestion API (`/api/order`):
    - [x] Defined comprehensive `orderSchema` (including nested `itemSchema`) matching Prisma model.
    - [x] Implemented `ordersSchema.safeParse()` for request body.
    - [x] Return 400 on validation failure with detailed field errors.
- [x] **Schema Definitions (`prisma/schema.prisma`):**
  - [x] Standardized all model IDs to `String @id @default(uuid()) @db.Uuid`.
  - [x] Define `Segment` model:
    - [x] Fields: `id` (UUID, PK), `name` (String), `rules` (JSON), `audienceUserIds` (String[] of UUIDs), `createdAt`, `updatedAt`.
    - [x] Relation: `Campaigns[]`.
    - [x] Added `@@index([name])`.
  - [x] Define `Campaign` model:
    - [x] Fields: `id` (UUID, PK), `name` (String), `messageTemplate` (String), `segmentId` (UUID, FK to Segment), `status` (Enum), `audienceSize`, `sentCount`, `failedCount`, `createdAt`, `updatedAt`.
    - [x] Relation: `Segment`, `CommunicationLog[]`.
    - [x] Simplified `CampaignStatus` to `PROCESSING`, `COMPLETED`.
    - [x] Removed `scheduledAt` field. Default status to `PROCESSING`.
    - [x] Added `@@index([segmentId])`, `@@index([status])`.
  - [x] Define `CommunicationLog` model:
    - [x] Fields: `id` (UUID, PK), `campaignId` (UUID, FK to Campaign), `customerId` (UUID, FK to User), `status` (Enum), `personalizedMessage`, `sentAt`, `vendorMessageId`, `deliveryReceiptStatus`, `createdAt`, `updatedAt`.
    - [x] Relation: `Campaign`, `User`.
    - [x] Added `@@index([campaignId])`, `@@index([customerId])`, `@@index([status])`.
  - [x] Added Enums: `CampaignStatus`, `CommunicationStatus`.
  - [x] Added `communicationLogs CommunicationLog[]` to `User` model.
  - [x] Ran `npx prisma migrate dev` successfully.
  - [x] Ran `npx prisma generate` successfully.
- [x] **Audience Segmentation & Preview:**
  - [x] API Endpoint: `POST /api/segments/preview`
    - [x] Define Zod schema for rule structure (`segmentRulesSchema`, `conditionGroupSchema`, `conditionSchema`).
    - [x] Input: `rules` (JSON object representing segment logic).
    - [x] Validation: Zod schema for rules structure.
    - [x] Logic: (Implementation Complete - Needs Testing & Potential Optimization)
      - [x] Parse `rules`.
      - [x] Fetch Users with Orders and Address (using Prisma-generated types).
      - [x] Implement helper `calculateUserAggregates(user)` for `totalSpend`, `orderCount`, `lastOrderDate`.
      - [x] Implement helper `evaluateCondition(user, aggregates, condition)` for individual rule conditions.
      - [x] Implement helper `evaluateUserAgainstRuleGroups(user, aggregates, rules)` for OR/AND logic.
      - [x] Iterate through users, apply rules, count matches, collect sample IDs.
    - [x] Output: `{ "audienceSize": number, "sampleUserIds": ["id1", "id2", ...] }`.
  - [x] API Endpoint: `POST /api/segments` (to create and save a segment for a campaign)
    - [x] Define Zod schema for input (`name`, `rules`).
    - [x] Input: `name` (String), `rules` (JSON).
    - [x] Validation: Zod schema for input.
    - [x] Logic:
      - [x] Parse `rules`.
      - [x] Reuse segmentation logic from preview (`calculateUserAggregates`, `evaluateCondition`, `evaluateUserAgainstRuleGroups`) to get `audienceUserIds`.
      - [x] Store `Segment` in DB with `name`, `rules` (as JSON), and `audienceUserIds` (array of strings).
    - [x] Output: Saved segment object.
  - [x] API Endpoint: `GET /api/segments` (list all segments)
    - [x] Logic: Fetch all segments from DB, order by `createdAt` descending.
    - [x] Output: Array of segment objects.
  - [x] API Endpoint: `GET /api/segments/:id` (get specific segment details)
    - [x] Logic: Fetch segment by ID from DB. Validate ID format.
    - [x] Output: Single segment object or 404 if not found.
- [x] **Campaign Creation & Scheduling:**
  - [x] API Endpoint: `POST /api/campaigns` (Handles combined Segment & Campaign creation)
    - [x] Define Zod schema for input (`campaignName`, `message`, `segmentName`, `segmentRules`).
    - [x] Input: `campaignName` (String), `message` (String), `segmentName` (String), `segmentRules` (JSON).
    - [x] Validation: Zod schema for input.
    - [x] Logic:
      - [x] Create `Segment` record in DB using `segmentName` and `segmentRules` (calculating audience).
      - [x] Create `Campaign` record in DB using the new segment's ID, with `status = PROCESSING`.
      - [x] Add a job to the BullMQ queue for processing. (Placeholder added, console log active)
    - [x] Output: Created segment and campaign objects.
  - [x] API Endpoint: `GET /api/campaigns` (list all campaigns)
    - [x] Logic: Fetch all campaigns, order by `createdAt` desc, include segment name.
    - [x] Output: Array of campaign objects with `segmentName`.
  - [x] API Endpoint: `GET /api/campaigns/:id` (get specific campaign details)
    - [x] Logic: Fetch campaign by ID, include detailed segment info (name, id, rules, audienceUserIds).
    - [x] Output: Single campaign object with nested segment details.
  - [ ] API Endpoint: `DELETE /api/campaigns/:id` (cancel campaign - only if `PROCESSING` and not yet fully sent, or mark as `CANCELLED` if new status is added)
    - Output: Success message.
- [ ] **API Documentation:**
  - [ ] Document request/response payloads for all core API endpoints (User, Order, Segment, Campaign).

## Phase 3: Authentication & AI Integration

- [ ] **Authentication (Google OAuth 2.0 with NextAuth.js or similar):**
  - [ ] Setup NextAuth.js.
  - [ ] Implement Google Provider.
  - [ ] Protect relevant API routes (e.g., segment creation, campaign creation, viewing history) - only logged-in users.
  - [ ] Store user session.
- [ ] **AI Integration (Choose at least one):**
  - [ ] **Option 1: Natural Language to Segment Rules**
    - [ ] UI for text input.
    - [ ] Backend API to take text, call LLM (e.g., OpenAI, Vertex AI).
    - [ ] LLM prompt engineering to convert text to structured rule JSON.
    - [ ] Present suggested rules to user for confirmation.
  - [ ] **Option 2: AI-Driven Message Suggestions**
    - [ ] UI element in campaign creation.
    - [ ] Backend API takes campaign objective/audience summary.
    - [ ] Call LLM to generate 2-3 message variants.
  - [ ] **Option 3: Campaign Performance Summarization**
    - [ ] On campaign details page/dashboard.
    - [ ] Backend logic gathers stats.
    - [ ] Call LLM with stats to generate human-readable summary.
  - [ ] Document AI tool used, API keys (use .env), and rationale.

## Phase 4: Dashboard & Finalization

- [ ] **Dashboard APIs:**
  - [ ] API Endpoint: `GET /api/dashboard/stats`
    - Logic:
      - `totalCustomers`: Count from `User` table.
      - `activeCampaigns`: Count from `Campaign` table (status = SENDING or PROCESSING).
      - `overallDeliveryRate`: Calculate from all `CommunicationLog`s or sum of `Campaign` stats.
      - `customerSegmentsCount`: Count from `Segment` table.
    - Output: `{ totalCustomers: number, activeCampaigns: number, deliveryRate: number, customerSegments: number }`.
- [ ] **Deployment (Vercel/Render/Railway):**
  - [ ] Configure environment variables.
  - [ ] Deploy application.
  - [ ] Test deployed version.
- [ ] **Demo Video (max 7 mins):**
  - [ ] Plan script: Features, problem approach, trade-offs, AI.
  - [ ] Record and edit.
- [ ] **README.md Updates:**
  - [ ] Final local setup instructions.
  - [ ] Architecture diagram (update with final components).
  - [ ] Summary of AI tools and tech used.
  - [ ] Known limitations or assumptions.
